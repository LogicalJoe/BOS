<html><head><title>bos.inc docs</title><link rel="stylesheet" type="text/css" href="style.css"></head><body><h1>"bos.inc" documentation</h1><h3>syscalls marked in <a class="no_op">red</a> are no-ops and do nothing.</h3><table><th>syscall name</th><th>syscall adress</th><th>links</th><tr><td>bos.boot_os</td><td>020108</td><td><a href="#boot_os">doc</a></tr>
<tr><td>bos.handle_interrupt</td><td>02010C</td><td><a href="#handle_interrupt">doc</a></tr>
<tr class="no_op"><td>bos.DONOTHING </td><td>020110</td><td><a href="#DONOTHING ">doc</a></tr>
<tr class="no_op"><td>bos.DONOTHING </td><td>020114</td><td><a href="#DONOTHING ">doc</a></tr>
<tr><td>bos.handle_safeop </td><td>020118</td><td><a href="#handle_safeop ">doc</a></tr>
<tr class="no_op"><td>bos.DONOTHING </td><td>02011C</td><td><a href="#DONOTHING ">doc</a></tr>
<tr class="no_op"><td>bos.DONOTHING </td><td>020120</td><td><a href="#DONOTHING ">doc</a></tr>
<tr><td>bos.sys_ExecuteFile</td><td>020124</td><td><a href="#sys_ExecuteFile">doc</a></tr>
<tr><td>bos.sys_ExecuteFileEntryPoint</td><td>020128</td><td><a href="#sys_ExecuteFileEntryPoint">doc</a></tr>
<tr><td>bos.fs_OpenFile</td><td>02012C</td><td><a href="#fs_OpenFile">doc</a></tr>
<tr><td>bos.fs_GetSectorAddress</td><td>020130</td><td><a href="#fs_GetSectorAddress">doc</a></tr>
<tr><td>bos.fs_CheckDirExists</td><td>020134</td><td><a href="#fs_CheckDirExists">doc</a></tr>
<tr><td>bos.fs_GetPathLastName</td><td>020138</td><td><a href="#fs_GetPathLastName">doc</a></tr>
<tr><td>bos.fs_CopyFileName</td><td>02013C</td><td><a href="#fs_CopyFileName">doc</a></tr>
<tr><td>bos.fs_Read</td><td>020140</td><td><a href="#fs_Read">doc</a></tr>
<tr><td>bos.fs_Write</td><td>020144</td><td><a href="#fs_Write">doc</a></tr>
<tr><td>bos.sys_AddHLAndA</td><td>020148</td><td><a href="#sys_AddHLAndA">doc</a></tr>
<tr><td>bos.sys_AnyKey</td><td>02014C</td><td><a href="#sys_AnyKey">doc</a></tr>
<tr><td>bos.sys_FreeAll</td><td>020150</td><td><a href="#sys_FreeAll">doc</a></tr>
<tr><td>bos.sys_GetKey</td><td>020154</td><td><a href="#sys_GetKey">doc</a></tr>
<tr><td>bos.sys_KbScan</td><td>020158</td><td><a href="#sys_KbScan">doc</a></tr>
<tr><td>bos.sys_Malloc</td><td>02015C</td><td><a href="#sys_Malloc">doc</a></tr>
<tr><td>bos.sys_MemCmp</td><td>020160</td><td><a href="#sys_MemCmp">doc</a></tr>
<tr><td>bos.sys_MemSet</td><td>020164</td><td><a href="#sys_MemSet">doc</a></tr>
<tr><td>bos.sys_Mult24x8</td><td>020168</td><td><a href="#sys_Mult24x8">doc</a></tr>
<tr><td>bos.sys_WaitKey</td><td>02016C</td><td><a href="#sys_WaitKey">doc</a></tr>
<tr><td>bos.sys_WaitKeyCycle</td><td>020170</td><td><a href="#sys_WaitKeyCycle">doc</a></tr>
<tr><td>bos.gui_DrawConsoleWindow</td><td>020174</td><td><a href="#gui_DrawConsoleWindow">doc</a></tr>
<tr><td>bos.gui_Input</td><td>020178</td><td><a href="#gui_Input">doc</a></tr>
<tr><td>bos.gui_NewLine</td><td>02017C</td><td><a href="#gui_NewLine">doc</a></tr>
<tr><td>bos.gui_Print</td><td>020180</td><td><a href="#gui_Print">doc</a></tr>
<tr><td>bos.gui_PrintInt</td><td>020184</td><td><a href="#gui_PrintInt">doc</a></tr>
<tr><td>bos.gui_Scroll</td><td>020188</td><td><a href="#gui_Scroll">doc</a></tr>
<tr><td>bos.gfx_BlitBuffer</td><td>02018C</td><td><a href="#gfx_BlitBuffer">doc</a></tr>
<tr><td>bos.gfx_PrintString</td><td>020190</td><td><a href="#gfx_PrintString">doc</a></tr>
<tr><td>bos._MemClear</td><td>020194</td><td><a href="#_MemClear">doc</a></tr>
<tr><td>bos._PushOP1</td><td>020198</td><td><a href="#_PushOP1">doc</a></tr>
<tr><td>bos._PopOP1</td><td>02019C</td><td><a href="#_PopOP1">doc</a></tr>
<tr><td>bos._Mov9ToOP1</td><td>0201A0</td><td><a href="#_Mov9ToOP1">doc</a></tr>
<tr><td>bos._CpHLDE</td><td>0201A4</td><td><a href="#_CpHLDE">doc</a></tr>
<tr><td>bos._Mov8b</td><td>0201A8</td><td><a href="#_Mov8b">doc</a></tr>
<tr><td>bos._ChkFindSym</td><td>0201AC</td><td><a href="#_ChkFindSym">doc</a></tr>
<tr><td>bos._LoadDEInd_s</td><td>0201B0</td><td><a href="#_LoadDEInd_s">doc</a></tr>
<tr><td>bos._EnoughMem</td><td>0201B4</td><td><a href="#_EnoughMem">doc</a></tr>
<tr><td>bos._InsertMem</td><td>0201B8</td><td><a href="#_InsertMem">doc</a></tr>
<tr><td>bos._SetHLUTo0</td><td>0201BC</td><td><a href="#_SetHLUTo0">doc</a></tr>
<tr><td>bos._PutS</td><td>0201C0</td><td><a href="#_PutS">doc</a></tr>
<tr><td>bos._GetCSC</td><td>0201C4</td><td><a href="#_GetCSC">doc</a></tr>
<tr><td>bos._NewLine</td><td>0201C8</td><td><a href="#_NewLine">doc</a></tr>
<tr><td>bos._ClrScrn</td><td>0201CC</td><td><a href="#_ClrScrn">doc</a></tr>
<tr><td>bos._HomeUp</td><td>0201D0</td><td><a href="#_HomeUp">doc</a></tr>
<tr><td>bos._ErrMemory</td><td>0201D4</td><td><a href="#_ErrMemory">doc</a></tr>
<tr><td>bos._DrawStatusBar</td><td>0201D8</td><td><a href="#_DrawStatusBar">doc</a></tr>
<tr><td>bos._os_GetSystemInfo</td><td>0201DC</td><td><a href="#_os_GetSystemInfo">doc</a></tr>
<tr><td>bos._UsbPowerVbus</td><td>0201E0</td><td><a href="#_UsbPowerVbus">doc</a></tr>
<tr><td>bos._UsbUnpowerVbus</td><td>0201E4</td><td><a href="#_UsbUnpowerVbus">doc</a></tr>
<tr><td>bos.sys_EraseFlashSector</td><td>0201E8</td><td><a href="#sys_EraseFlashSector">doc</a></tr>
<tr><td>bos.sys_FlashUnlock</td><td>0201EC</td><td><a href="#sys_FlashUnlock">doc</a></tr>
<tr><td>bos.sys_FlashLock</td><td>0201F0</td><td><a href="#sys_FlashLock">doc</a></tr>
<tr><td>bos.fs_CreateFile</td><td>0201F4</td><td><a href="#fs_CreateFile">doc</a></tr>
<tr><td>bos.strupper</td><td>0201F8</td><td><a href="#strupper">doc</a></tr>
<tr><td>bos.strlower</td><td>0201FC</td><td><a href="#strlower">doc</a></tr>
<tr><td>bos.fs_AbsPath</td><td>020200</td><td><a href="#fs_AbsPath">doc</a></tr>
<tr><td>bos.fs_MultByBytesPerSector</td><td>020204</td><td><a href="#fs_MultByBytesPerSector">doc</a></tr>
<tr><td>bos._LoadLibraryOP1</td><td>020208</td><td><a href="#_LoadLibraryOP1">doc</a></tr>
<tr><td>bos.fs_OpenFileInDir</td><td>02020C</td><td><a href="#fs_OpenFileInDir">doc</a></tr>
<tr><td>bos.fs_SetSize</td><td>020210</td><td><a href="#fs_SetSize">doc</a></tr>
<tr><td>bos.fs_WriteFile</td><td>020214</td><td><a href="#fs_WriteFile">doc</a></tr>
<tr><td>bos.sys_HLToString</td><td>020218</td><td><a href="#sys_HLToString">doc</a></tr>
<tr><td>bos.fs_DeleteFile</td><td>02021C</td><td><a href="#fs_DeleteFile">doc</a></tr>
<tr><td>bos._DelVar</td><td>020220</td><td><a href="#_DelVar">doc</a></tr>
<tr><td>bos._CreateVar</td><td>020224</td><td><a href="#_CreateVar">doc</a></tr>
<tr><td>bos.gui_InputNoClear</td><td>020228</td><td><a href="#gui_InputNoClear">doc</a></tr>
<tr><td>bos.fs_InitClusterMap</td><td>02022C</td><td><a href="#fs_InitClusterMap">doc</a></tr>
<tr><td>bos.sys_WriteFlash</td><td>020230</td><td><a href="#sys_WriteFlash">doc</a></tr>
<tr><td>bos.sys_WriteFlashA</td><td>020234</td><td><a href="#sys_WriteFlashA">doc</a></tr>
<tr><td>bos.sys_WriteFlashFull</td><td>020238</td><td><a href="#sys_WriteFlashFull">doc</a></tr>
<tr><td>bos.sys_WriteFlashByteFull</td><td>02023C</td><td><a href="#sys_WriteFlashByteFull">doc</a></tr>
<tr><td>bos.fs_ParentDir</td><td>020240</td><td><a href="#fs_ParentDir">doc</a></tr>
<tr><td>bos.fs_StrToFileEntry</td><td>020244</td><td><a href="#fs_StrToFileEntry">doc</a></tr>
<tr><td>bos.fs_DirList</td><td>020248</td><td><a href="#fs_DirList">doc</a></tr>
<tr><td>bos.sys_Free</td><td>02024C</td><td><a href="#sys_Free">doc</a></tr>
<tr><td>bos.sys_CallExecuteFile</td><td>020250</td><td><a href="#sys_CallExecuteFile">doc</a></tr>
<tr><td>bos.sys_JumpExecuteFile</td><td>020254</td><td><a href="#sys_JumpExecuteFile">doc</a></tr>
<tr><td>bos.sys_InitDevice</td><td>020258</td><td><a href="#sys_InitDevice">doc</a></tr>
<tr><td>bos.sys_DeinitDevice</td><td>02025C</td><td><a href="#sys_DeinitDevice">doc</a></tr>
<tr><td>bos.sys_GetDeviceAddress</td><td>020260</td><td><a href="#sys_GetDeviceAddress">doc</a></tr>
<tr><td>bos.sys_ReadDevice</td><td>020264</td><td><a href="#sys_ReadDevice">doc</a></tr>
<tr><td>bos.sys_WriteDevice</td><td>020268</td><td><a href="#sys_WriteDevice">doc</a></tr>
<tr><td>bos.fs_GetSector</td><td>02026C</td><td><a href="#fs_GetSector">doc</a></tr>
<tr><td>bos.fs_WriteByte</td><td>020270</td><td><a href="#fs_WriteByte">doc</a></tr>
<tr><td>bos.fs_RenameFile</td><td>020274</td><td><a href="#fs_RenameFile">doc</a></tr>
<tr><td>bos._SetCursorPos</td><td>020278</td><td><a href="#_SetCursorPos">doc</a></tr>
</table><div id="boot_os"><h1>boot_os</h1><h3>syscall Adress 020108</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="handle_interrupt"><h1>handle_interrupt</h1><h3>syscall Adress 02010C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="handle_safeop "><h1>handle_safeop </h1><h3>syscall Adress 020118</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
</table></div><div id="sys_ExecuteFile"><h1>sys_ExecuteFile</h1><h3>syscall Adress 020124</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> int sys_ExecuteFile(char *path, char *args);</td><td> execute a file</td><td> -1 if file does not exist or is not a valid executable format<br>
 ExecutingFileFd set to point to file descriptor. -1 if file not found</td><td> All, OP6.</td><td>
</td></tr>
</table></div><div id="sys_ExecuteFileEntryPoint"><h1>sys_ExecuteFileEntryPoint</h1><h3>syscall Adress 020128</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> int sys_ExecuteFileEntryPoint(char *path, char *args);</td><td> execute a file from a given entry point</td><td> -1 if file does not exist or is not a valid executable format</td><td></td><td>
 entry point is essentially "file.whatever:entrypoint/whatever"</td></tr>
</table></div><div id="fs_OpenFile"><h1>fs_OpenFile</h1><h3>syscall Adress 02012C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> void *fs_OpenFile(char *path);</td><td> Opens a file from a path and returns file descriptor.</td><td> hl = file descriptor. hl is -1 if file does not exist.</td><td> All</td><td>
 This only searches for short 8.3 file names.</td></tr>
</table></div><div id="fs_GetSectorAddress"><h1>fs_GetSectorAddress</h1><h3>syscall Adress 020130</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> void *fs_GetSectorAddress(uint16_t sector);</td><td> get the physical address of a given sector.</td><td></td><td></td><td>
</td></tr>
</table></div><div id="fs_CheckDirExists"><h1>fs_CheckDirExists</h1><h3>syscall Adress 020134</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> bool fs_CheckDirExists(char *path);</td><td> check if a directory exists.</td><td> true if path exists, else false</td><td></td><td>
 uses InputBuffer and fsOP6</td></tr>
</table></div><div id="fs_GetPathLastName"><h1>fs_GetPathLastName</h1><h3>syscall Adress 020138</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> char *fs_GetPathLastName(char *path);</td><td> get last file name from a path. Equivalent to python path.split("/")[-1]</td><td> pointer to file name</td><td></td><td>
 this will return the last entry in the path, regardless of whether the path exists or if it points to a program entrypoint.</td></tr>
</table></div><div id="fs_CopyFileName"><h1>fs_CopyFileName</h1><h3>syscall Adress 02013C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> char *fs_CopyFileName(char *dest, void *fd);</td><td> copies file name from file descriptor</td><td> first byte of dest will be null if failed.</td><td></td><td>
</td></tr>
</table></div><div id="fs_Read"><h1>fs_Read</h1><h3>syscall Adress 020140</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> int fs_Read(void *dest, int len, uint8_t count, void *fd, int offset);</td><td> read data from a file into RAM</td><td> number of bytes read</td><td> All</td><td>
</td></tr>
</table></div><div id="fs_Write"><h1>fs_Write</h1><h3>syscall Adress 020144</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> int fs_Write(void *data, int len, uint8_t count, void *fd, int offset);</td><td> write data to a file</td><td> Returns -1 if failed to write</td><td> All. Assume OP5, OP6</td><td>
 file must be at least offset + len * count bytes in size.</td></tr>
</table></div><div id="sys_AddHLAndA"><h1>sys_AddHLAndA</h1><h3>syscall Adress 020148</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> HL number<br>
 A increment</td><td> HL+=A</td><td> HL number+increment</td><td> AF</td><td>
</td></tr>
</table></div><div id="sys_AnyKey"><h1>sys_AnyKey</h1><h3>syscall Adress 02014C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> Scans the keypad and updates data registers; checking if a key was pressed</td><td> 0 if no keys pressed</td><td> HL,AF</td><td>
</td></tr>
</table></div><div id="sys_FreeAll"><h1>sys_FreeAll</h1><h3>syscall Adress 020150</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> void sys_FreeAll(void);</td><td> Free all memory malloc'd by sys_Malloc</td><td></td><td> hl, de</td><td>
</td></tr>
</table></div><div id="sys_GetKey"><h1>sys_GetKey</h1><h3>syscall Adress 020154</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> Return current keypress</td><td> A keypress<br>
 z if no key pressed</td><td> HL,DE,BC,AF</td><td>
</td></tr>
</table></div><div id="sys_KbScan"><h1>sys_KbScan</h1><h3>syscall Adress 020158</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> Scans the keypad and updates data registers</td><td></td><td> HL,AF</td><td>
</td></tr>
</table></div><div id="sys_Malloc"><h1>sys_Malloc</h1><h3>syscall Adress 02015C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> void *sys_Malloc(size_t amt);</td><td> Allocate memory</td><td> hl = malloc'd bytes. hl = -1 if failed to malloc<br>
 Cf set if failed to malloc</td><td> All</td><td>
</td></tr>
</table></div><div id="sys_MemCmp"><h1>sys_MemCmp</h1><h3>syscall Adress 020160</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> HL,DE pointers to compare<br>
 BC number of bytes to compare</td><td> compare two memory pointers</td><td> Z flag set if success</td><td></td><td>
</td></tr>
</table></div><div id="sys_MemSet"><h1>sys_MemSet</h1><h3>syscall Adress 020164</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> HL pointer to set<br>
 BC amount to set<br>
 A byte to set memory to</td><td> set BC bytes of HL to the value A</td><td> HL HL+BC<br>
 DE HL+BC+1</td><td> AF</td><td>
</td></tr>
</table></div><div id="sys_Mult24x8"><h1>sys_Mult24x8</h1><h3>syscall Adress 020168</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> HL,A</td><td> Multiply HL (24 bit) by A (8 bit)</td><td> HL</td><td> AF</td><td>
</td></tr>
</table></div><div id="sys_WaitKey"><h1>sys_WaitKey</h1><h3>syscall Adress 02016C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> Wait until a key is pressed and return it</td><td></td><td> HL,DE,BC,AF</td><td>
</td></tr>
</table></div><div id="sys_WaitKeyCycle"><h1>sys_WaitKeyCycle</h1><h3>syscall Adress 020170</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> Wait until a key is pressed, then wait until it's released, then return the keycode</td><td> A = keycode</td><td> HL,DE,BC,AF</td><td>
</td></tr>
</table></div><div id="gui_DrawConsoleWindow"><h1>gui_DrawConsoleWindow</h1><h3>syscall Adress 020174</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> hl = string</td><td> clear the screen and display a string</td><td></td><td></td><td>
 resets the text colors to white on black</td></tr>
</table></div><div id="gui_Input"><h1>gui_Input</h1><h3>syscall Adress 020178</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> uint8_t gui_Input(char *buffer, int max_len);</td><td> get user input</td><td> 0 if user exit, 1 if user enter, 9/12 if user presses down/up arrow key</td><td> All</td><td>
</td></tr>
</table></div><div id="gui_NewLine"><h1>gui_NewLine</h1><h3>syscall Adress 02017C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gui_Print"><h1>gui_Print</h1><h3>syscall Adress 020180</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gui_PrintInt"><h1>gui_PrintInt</h1><h3>syscall Adress 020184</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> hl = integer</td><td> Print an integer. Does not swap buffers.</td><td></td><td></td><td>
</td></tr>
</table></div><div id="gui_Scroll"><h1>gui_Scroll</h1><h3>syscall Adress 020188</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_BlitBuffer"><h1>gfx_BlitBuffer</h1><h3>syscall Adress 02018C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="gfx_PrintString"><h1>gfx_PrintString</h1><h3>syscall Adress 020190</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="_MemClear"><h1>_MemClear</h1><h3>syscall Adress 020194</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> Clear (Zero) BC bytes at HL</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_PushOP1"><h1>_PushOP1</h1><h3>syscall Adress 020198</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> Push OP1 to the OP stack</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_PopOP1"><h1>_PopOP1</h1><h3>syscall Adress 02019C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> Pop OP1 from the OP stack</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_Mov9ToOP1"><h1>_Mov9ToOP1</h1><h3>syscall Adress 0201A0</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> move 9 bytes from HL to OP1</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_CpHLDE"><h1>_CpHLDE</h1><h3>syscall Adress 0201A4</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> compare HL to DE. Returns the resultant of "sbc hl,de" without modifying either.</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_Mov8b"><h1>_Mov8b</h1><h3>syscall Adress 0201A8</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> move 8 bytes from HL to DE</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_ChkFindSym"><h1>_ChkFindSym</h1><h3>syscall Adress 0201AC</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> OP1 1 byte var type, 8 byte file name</td><td> Search for a TI variable in the "/usr/tivars/" directory</td><td> HL = pointer to 2 byte file length<br>
 DE = pointer to file data<br>
 Cf set if file not found or otherwise cannot be opened.</td><td> OP4,OP5</td><td>
</td></tr>
</table></div><div id="_LoadDEInd_s"><h1>_LoadDEInd_s</h1><h3>syscall Adress 0201B0</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> load DE with 16-bit value at HL, advancing DE+=2</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_EnoughMem"><h1>_EnoughMem</h1><h3>syscall Adress 0201B4</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> Check if there are HL bytes avalible in userMem</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_InsertMem"><h1>_InsertMem</h1><h3>syscall Adress 0201B8</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> hl = bytes to insert</td><td> insert HL bytes into userMem at address DE</td><td> hl = new top of UserMem</td><td></td><td>
 this currently ignores DE and just moves the top of usermem forward HL bytes</td></tr>
</table></div><div id="_SetHLUTo0"><h1>_SetHLUTo0</h1><h3>syscall Adress 0201BC</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> Sets the top byte of HL to zero.</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_PutS"><h1>_PutS</h1><h3>syscall Adress 0201C0</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> HL = string</td><td> Print a string to the current cursor position and blit the buffer when finished.</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_GetCSC"><h1>_GetCSC</h1><h3>syscall Adress 0201C4</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
</table></div><div id="_NewLine"><h1>_NewLine</h1><h3>syscall Adress 0201C8</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
</table></div><div id="_ClrScrn"><h1>_ClrScrn</h1><h3>syscall Adress 0201CC</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> Clear the screen and back buffer</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_HomeUp"><h1>_HomeUp</h1><h3>syscall Adress 0201D0</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> Set the cursor position to 0,0</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_ErrMemory"><h1>_ErrMemory</h1><h3>syscall Adress 0201D4</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> Quit the program and display a memory error message</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_DrawStatusBar"><h1>_DrawStatusBar</h1><h3>syscall Adress 0201D8</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> Nothing for now. Basically just a compatibility define</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_os_GetSystemInfo"><h1>_os_GetSystemInfo</h1><h3>syscall Adress 0201DC</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> return system info. Compatibility define. It actually returns 0xFF0000. lol</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_UsbPowerVbus"><h1>_UsbPowerVbus</h1><h3>syscall Adress 0201E0</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> I honestly don't know. Included this routine for compatibility with USBDDRVCE.</td><td></td><td></td><td>
</td></tr>
</table></div><div id="_UsbUnpowerVbus"><h1>_UsbUnpowerVbus</h1><h3>syscall Adress 0201E4</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> I honestly don't know. Included for compatibility with USBDRVCE.</td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_EraseFlashSector"><h1>sys_EraseFlashSector</h1><h3>syscall Adress 0201E8</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> A sector to erase</td><td> Erase flash sector</td><td></td><td> All</td><td>
 calls boot routine $2DC</td></tr>
</table></div><div id="sys_FlashUnlock"><h1>sys_FlashUnlock</h1><h3>syscall Adress 0201EC</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_FlashLock"><h1>sys_FlashLock</h1><h3>syscall Adress 0201F0</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td></td><td></td><td></td><td>
</td></tr>
</table></div><div id="fs_CreateFile"><h1>fs_CreateFile</h1><h3>syscall Adress 0201F4</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> void *fs_CreateFile(const char *path, uint8_t flags, int len);</td><td> Create a file given a path and return a file descriptor.</td><td> file descriptor. Returns 0 if failed to create file.</td><td></td><td>
</td></tr>
</table></div><div id="strupper"><h1>strupper</h1><h3>syscall Adress 0201F8</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> HL pointer to string</td><td> convert a string to uppercase</td><td> HL HL+strlen(HL)</td><td> AF</td><td>
</td></tr>
</table></div><div id="strlower"><h1>strlower</h1><h3>syscall Adress 0201FC</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> HL pointer to string</td><td> convert a string to lowercase</td><td> HL HL+strlen(HL)</td><td> AF</td><td>
</td></tr>
</table></div><div id="fs_AbsPath"><h1>fs_AbsPath</h1><h3>syscall Adress 020200</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> char *fs_AbsPath(const char *path);</td><td> get absolute path representation of hl</td><td> hl = absolute path. Will be equal to the input if it is already an absolute path<br>
 Cf set if failed</td><td></td><td>
</td></tr>
</table></div><div id="fs_MultByBytesPerSector"><h1>fs_MultByBytesPerSector</h1><h3>syscall Adress 020204</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> HL = number</td><td> multiply by the number of bytes per sector</td><td> HL*=256</td><td> BC,DE,AF</td><td>
</td></tr>
</table></div><div id="_LoadLibraryOP1"><h1>_LoadLibraryOP1</h1><h3>syscall Adress 020208</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> OP1 name of library</td><td> locate and return a pointer to a library from a ".LLL" file in the "/lib/" directory</td><td> hl points to file length, de points to file data. Cf set if failed</td><td></td><td>
</td></tr>
</table></div><div id="fs_OpenFileInDir"><h1>fs_OpenFileInDir</h1><h3>syscall Adress 02020C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> void *fs_OpenFileInDir(char *path, void *dir);</td><td> Opens a file given a path and a pointer to the dir to start searching from. Returns file descriptor.</td><td> hl = file descriptor. hl is -1 if file does not exist.</td><td> All</td><td>
 This only searches for short 8.3 file names.</td></tr>
</table></div><div id="fs_SetSize"><h1>fs_SetSize</h1><h3>syscall Adress 020210</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> bool fs_SetSize(int len, void *fd);</td><td> Resizes a file descriptor.</td><td> true if resizing succeeded</td><td></td><td>
 Will allocate enough sectors to contain len bytes.</td></tr>
</table></div><div id="fs_WriteFile"><h1>fs_WriteFile</h1><h3>syscall Adress 020214</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> int WriteFile(void *data, int len, void *fd);</td><td> Overwrite all data stored in a file from a given data pointer.</td><td> number of bytes written. 0 if failed to write</td><td></td><td>
 Only the number of clusters aready allocated to the file will be written. Call fs_SetSize() to reallocate file clusters.</td></tr>
</table></div><div id="sys_HLToString"><h1>sys_HLToString</h1><h3>syscall Adress 020218</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> HL = number to convert</td><td> convert a number to a string</td><td> DE = string<br>
 string stored at gfx_string_temp</td><td></td><td>
</td></tr>
</table></div><div id="fs_DeleteFile"><h1>fs_DeleteFile</h1><h3>syscall Adress 02021C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> bool fs_DeleteFile(void *fd);</td><td> delete a file given a file descriptor</td><td> true if success, otherwise fail</td><td></td><td>
</td></tr>
</table></div><div id="_DelVar"><h1>_DelVar</h1><h3>syscall Adress 020220</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> OP1 = type byte, 8 byte name of var to delete</td><td> delete a file in the /usr/tivars/ directory</td><td> Cf set if failed</td><td></td><td>
</td></tr>
</table></div><div id="_CreateVar"><h1>_CreateVar</h1><h3>syscall Adress 020224</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> OP1 = type byte, 8 byte name of var to create<br>
 hl = length to allocate for file</td><td> create a file in the /usr/tivars/ directory</td><td> Cf set if failed</td><td></td><td>
</td></tr>
</table></div><div id="gui_InputNoClear"><h1>gui_InputNoClear</h1><h3>syscall Adress 020228</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> uint8_t gui_InputNoClear(char *buffer, int max_len);</td><td> get user input without clearing the provided buffer first.</td><td> 0 if user exit, 1 if user enter, 9/12 if user presses down/up arrow key</td><td> All</td><td>
</td></tr>
</table></div><div id="fs_InitClusterMap"><h1>fs_InitClusterMap</h1><h3>syscall Adress 02022C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> void fs_InitClusterMap(void);</td><td> initialize cluster map given data within the file system.</td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_WriteFlash"><h1>sys_WriteFlash</h1><h3>syscall Adress 020230</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> HL, DE, BC</td><td> write BC bytes to flash from HL to DE.</td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_WriteFlashA"><h1>sys_WriteFlashA</h1><h3>syscall Adress 020234</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> A, DE</td><td> write a byte from A to flash at address DE</td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_WriteFlashFull"><h1>sys_WriteFlashFull</h1><h3>syscall Adress 020238</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td></td><td> store data to flash, surpassing flash AND logic using the swap sector.</td><td> bool sys_WriteFlashFull(void *dest, void *src, int len);</td><td></td><td>
 erases swap sector, copies dest sector to swap sector excluding the data write area, writes data, erases dest sector, copies swap sector to dest sector.<br>
 source and destination cannot be within the same sector.</td></tr>
</table></div><div id="sys_WriteFlashByteFull"><h1>sys_WriteFlashByteFull</h1><h3>syscall Adress 02023C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> bool sys_WriteFlashByteFull(void *dest, uint8_t byte);</td><td> Write a byte to flash, surpassing flash AND logic using the swap sector if needed.</td><td> true if success, false if failed</td><td></td><td>
</td></tr>
</table></div><div id="fs_ParentDir"><h1>fs_ParentDir</h1><h3>syscall Adress 020240</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> char *fs_ParentDir(const char *path);</td><td> return a string representing the parent directory of a given path</td><td></td><td></td><td>
</td></tr>
</table></div><div id="fs_StrToFileEntry"><h1>fs_StrToFileEntry</h1><h3>syscall Adress 020244</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> char *fs_StrToFileEntry(char *dest, const char *src);</td><td> convert a file.ext string to a file entry</td><td> pointer to file entry, 0 if failed<br>
 Cf set if failed</td><td></td><td>
</td></tr>
</table></div><div id="fs_DirList"><h1>fs_DirList</h1><h3>syscall Adress 020248</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> void **fs_DirList(void **buffer, const char *path, int num, int skip);</td><td> list items in a directory</td><td> pointer to array of dir entry pointers. Returns -1 and Cf on fail</td><td></td><td>
</td></tr>
</table></div><div id="sys_Free"><h1>sys_Free</h1><h3>syscall Adress 02024C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> void sys_Free(void *ptr);</td><td> Free as block of memory malloc'd by sys_Malloc</td><td></td><td> All</td><td>
</td></tr>
</table></div><div id="sys_CallExecuteFile"><h1>sys_CallExecuteFile</h1><h3>syscall Adress 020250</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> hl = file to execute<br>
 de = arguments<br>
 bc = file to return to</td><td> Jump execution to an executable file and return to caller</td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_JumpExecuteFile"><h1>sys_JumpExecuteFile</h1><h3>syscall Adress 020254</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> hl = file to execute<br>
 de = arguments</td><td> Jump execution to an executable file</td><td></td><td></td><td>
</td></tr>
</table></div><div id="sys_InitDevice"><h1>sys_InitDevice</h1><h3>syscall Adress 020258</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> void *sys_InitDevice(const char *name);</td><td> Initialize a device given a path to it</td><td> pointer to device file descriptor<br>
 hl=-1 and Cf set if failed</td><td></td><td>
</td></tr>
</table></div><div id="sys_DeinitDevice"><h1>sys_DeinitDevice</h1><h3>syscall Adress 02025C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> int sys_DeinitDevice(void *fd);</td><td> Deinitialize a device given a pointer to its file descriptor</td><td> hl = -1 and Cf set if failed. Otherwise assume 0.</td><td></td><td>
</td></tr>
</table></div><div id="sys_GetDeviceAddress"><h1>sys_GetDeviceAddress</h1><h3>syscall Adress 020260</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> void *sys_GetDeviceAddress(void *dest, void *src, size_t len, void *fd);</td><td> Get a pointer for raw access to a device given a file descriptor</td><td> assume hl points to device address. Device return may vary. Some devices do not have a physical address.<br>
 hl = 0 and Cf set if failed</td><td></td><td>
</td></tr>
</table></div><div id="sys_ReadDevice"><h1>sys_ReadDevice</h1><h3>syscall Adress 020264</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> int sys_ReadDevice(void *dest, void *src, size_t len, void *fd);</td><td> Read from a device given a file descriptor</td><td> assume hl = number of bytes read. Device return may vary.<br>
 hl = 0 and Cf set if failed</td><td></td><td>
</td></tr>
</table></div><div id="sys_WriteDevice"><h1>sys_WriteDevice</h1><h3>syscall Adress 020268</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> int sys_WriteDevice(void *dest, void *src, size_t len, void *fd);</td><td> Write to a device given a file descriptor</td><td> assume hl = number of bytes written. Device return may vary.<br>
 hl = 0 and Cf set if failed</td><td></td><td>
</td></tr>
</table></div><div id="fs_GetSector"><h1>fs_GetSector</h1><h3>syscall Adress 02026C</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> int fs_GetSector(void *address);</td><td> get the sector a given address lies within</td><td></td><td></td><td>
</td></tr>
</table></div><div id="fs_WriteByte"><h1>fs_WriteByte</h1><h3>syscall Adress 020270</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> int fs_WriteByte(uint8_t byte, void *fd, int offset);</td><td> write a byte into a file</td><td></td><td></td><td>
</td></tr>
</table></div><div id="fs_RenameFile"><h1>fs_RenameFile</h1><h3>syscall Adress 020274</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> void *fs_RenameFile(const char *directory, const char *old_name, const char *new_name);</td><td> rename a file</td><td> file descriptor. returns zero if failed</td><td></td><td>
</td></tr>
</table></div><div id="_SetCursorPos"><h1>_SetCursorPos</h1><h3>syscall Adress 020278</h3>
<table><th>Inputs</th><th>What it does</th><th>Outputs</th><th>Destroys</th><th>Notes</th>
<tr><td> void _SetCursorPos(uint8_t row, uint8_t col);</td><td> Set the text cursor position</td><td></td><td></td><td>
</td></tr>
</table></div></body></html>